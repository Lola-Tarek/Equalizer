# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainwin.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


import PyQt5.QtGui
import PyQt5.QtWidgets
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import pyqtgraph as pg
import pyqtgraph.exporters
import soundfile as sf
from PyQt5 import QtGui, QtWidgets
from pyqtgraph import PlotWidget
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter
from reportlab.platypus import Image
from reportlab.platypus import SimpleDocTemplate
from reportlab.platypus import Table
from reportlab.platypus import TableStyle
import mainlayout
from spectrogram import Ui_OtherWindow
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from scipy.io.wavfile import write
#import simpleaudio as sa
import winsound


class Pin():
    def __init__(self):
        self.title = ''
        self.SignalPath_before = []
        self.SignalPath_after = []
        self.GramPath = []
        self.pinElementTable = None

    def getPins(self, path):
        name = path.split("/")[-1]
        self.title = name
        self.SignalPath_before = [name + ".png"]
        self.SignalPath_after = [name + "m" + ".png"]
        self.GramPath = [name + "s" + ".png"]

    def genPinTable(self):
        pinElemTable = None
        pinElemWidth = 500
        pinElemHeight = 1000

        # 1) Build Structure

        titleTable = Table([[self.title]] , pinElemWidth)

        S_picture_before = Image(self.SignalPath_before[0])
        #S_picture_before = Image("test1.png")
        S_picture_before.drawWidth = 200
        S_picture_before.drawHeight = 100

        S_picture_after = Image(self.SignalPath_after[0])
        #S_picture_after = Image("test1.png")
        S_picture_after.drawWidth = 200
        S_picture_after.drawHeight = 100

        G_picture = Image(self.GramPath[0])
        #G_picture = Image("test1.png")
        G_picture.drawWidth = 200
        G_picture.drawHeight = 100

        picSignal_before = Table([
            [S_picture_before]
        ], 250, 125)
        picSignal_after = Table([
            [S_picture_after]
        ], 250, 125)
        picGram = Table([
            [G_picture]
        ], 250, 125)

        PicTable = Table([
            [picSignal_before, picSignal_after],
            [picGram]
        ], [250, 250])

        self.pinElemTable = Table([
            [titleTable],
            [PicTable]
        ], pinElemWidth)

        # 2) Add Style
        # List available fonts
        '''
        from reportlab.pdfgen import canvas
        for font in canvas.Canvas('abc').getAvailableFonts(): 
            print(font)
        '''
        titleTableStyle = TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTSIZE', (0, 0), (-1, -1), 14),
            ('FONTNAME', (0, 0), (-1, -1),
             'Helvetica-Oblique'
             ),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ])
        titleTable.setStyle(titleTableStyle)

        picTableStyle = TableStyle([
            ('LEFTPADDING', (0, 0), (-1, -1), 15),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
        ])
        picSignal_before.setStyle(picTableStyle)
        picSignal_after.setStyle(picTableStyle)
        picGram.setStyle(picTableStyle)

        pinElemTableStyle = TableStyle([
            ('BOX', (0, 0), (-1, -1), 3, colors.pink),

            ('TOPPADDING', (0, 0), (-1, -1), 0),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 0),
        ])
        self.pinElemTable.setStyle(pinElemTableStyle)


class Window(QtWidgets.QMainWindow, mainlayout.Ui_MainWindow):
    signals_windows = {}  # store signals paths' and their object

    def __init__(self):
        super(Window, self).__init__()
        # Using functions in the inherited class
        self.setupUi(self)

        # set pg configuration
        pg.setConfigOptions(background='w')
        # anti aliasing to improve the appearance of a small image that's being scaled up
        pg.setConfigOptions(antialias=True)

        # set the title
        self.setWindowTitle("MainWindow")

        # variables declaration
        self.path = None
        self.original_data = None  # store original signal data
        self.sample_rate = None  # store sample rate from signal file
        self.fft = None
        self.frequencies = None
        self.magnitude_spectrum = None
        self.phase_spectrum = None
        self.modified_data = None
        self.spec_mag =None

        # plots
        self.original_waveform = None
        self.modified_waveform = None
        self.pallette = 'plasma'

        # self.signal = None  # have the created signal object
        self.pins = {}  # have signal path and created pin object
        self.signals_fft = {}
        self.selected_signal = None
        self.played = 0  # playing flag
        self.pause = 0  # pause flag
        self.step=3

        self.sliders = [self.eq_Slider_1,self.eq_Slider_2,self.eq_Slider_3,self.eq_Slider_4,self.eq_Slider_5,self.eq_Slider_6,self.eq_Slider_7,self.eq_Slider_8,self.eq_Slider_9,self.eq_Slider_10]
        self.gains=[self.gain1,self.gain2,self.gain3,self.gain4,self.gain5,self.gain6,self.gain7,self.gain8,self.gain9,self.gain10]
        self.current_values=[]
        self.new_amp=[]
        self.As = []


        # Actions
        self.actionOpen_signal.triggered.connect(self.open_sig)
        self.actionSave_signal_as.triggered.connect(self.save_sig)
        self.actionZoom_In.triggered.connect(lambda: self.zoom(1))
        self.actionZoom_out.triggered.connect(lambda: self.zoom(0))
        self.actionPlay_signal_no_sound.triggered.connect(lambda: self.play_signal(0))
        self.actionStop_playing.triggered.connect(self.pause_signal)
        self.action_Signal_beginning.triggered.connect(lambda: self.signal_beginning(1))
        self.actionLeft.triggered.connect(lambda: self.signal_beginning(0))  ##scroll to left
        self.actionRight.triggered.connect(lambda: self.signal_end(0))  ##scroll to Right
        self.actionSignal_End.triggered.connect(lambda: self.signal_end(1))
       
        self.actionSpeed_Up.triggered.connect(self.speed_up)
        self.actionSpeed_Down.triggered.connect(self.speed_down)

        self.Export_pdf.triggered.connect(self.E_pdf)
        self.actionSpectrogram.triggered.connect(self.spec_showhide)
        self.actionPlay_signal_with_sound.triggered.connect(self.play_sound)
        self.actionTime_FFT.triggered.connect(self.inverse_fft)
        self.radioButton1.toggled.connect(self.color_pallette)
        self.radioButton2.toggled.connect(self.color_pallette)
        self.radioButton3.toggled.connect(self.color_pallette)
        self.radioButton4.toggled.connect(self.color_pallette)
        self.radioButton5.toggled.connect(self.color_pallette)
        self.specSlider1.valueChanged.connect(self.spec_range)
        self.specSlider2.valueChanged.connect(self.spec_range)

        for slider in self.sliders:
            slider.valueChanged.connect(self.slider_step)
        
        #show window
        self.showMaximized()
        self.show()


    def spec_showhide(self):
        if self.frame_3.isVisible():
            self.frame_3.setVisible(False)
        else:
            self.frame_3.setVisible(True)

    def spec_range(self):
        min_index = None
        max_index = None
        min_freq = self.specSlider1.value()
        max_freq = self.specSlider2.value()

        self.spec_min_freq.setText(str(min_freq))
        self.spec_max_freq.setText(str(max_freq))

        min_index = int(np.where(self.frequencies == min_freq)[0])
        max_index = int(np.where(self.frequencies == max_freq)[0])

        modified_fft = np.fft.rfft(self.modified_data)
        modified_fft = modified_fft[min_index:max_index+1]
        self.spec_mag = np.fft.irfft(modified_fft)
        self.open_window()

    def open_window(self):
        self.spectro_draw(self.pallette)
        self.window = QtWidgets.QMainWindow()
        self.ui = Ui_OtherWindow()
        self.ui.setupUi(self.window)


    # open for signals .wav , .edf
    def open_sig(self):
        path = PyQt5.QtWidgets.QFileDialog.getOpenFileName(None, 'Open', None, "WAV (*.wav)")[0]
        if path:
            if len(self.signals_windows) == 0:
                self.signals_windows[path] = self
                self.signals_windows[path].path=path
                self.signals_windows[path]
            else:
                self.signals_windows[path] = OtherWindows()
                self.signals_windows[path].path=path
                self.signals_windows[path].config(path)

            # load .wav data
            self.signals_windows[path].original_data, self.signals_windows[path].sample_rate = sf.read(path)
            self.signals_windows[path].modified_data = self.signals_windows[path].original_data
            self.signals_windows[path].spec_mag = self.signals_windows[path].modified_data

            # create signal object and plot
            self.signals_windows[path].create_signal()

    
    
    def get_amplitude(self):
        b=int(len(self.frequencies)/10)
        self.current_values=[]
        for slider in self.sliders:
            self.current_values.append(slider.value())

        for i in range(9):
            self.As.append(list(self.magnitude_spectrum[i*b : (i+1)*b]))
        
        self.As.append(list(self.magnitude_spectrum[9*b:(10*b+1)]))


    #spectrogram sliders config
    def spec_sliders(self):
        #maximum Freq
        length=len(self.frequencies)
        self.specSlider2.setMinimum(self.frequencies[int(length/2)])
        self.specSlider2.setMaximum(self.frequencies[length-1])
        self.specSlider2.setValue(self.frequencies[length-1])
        #minimum Freq
        self.specSlider1.setMaximum(self.frequencies[int(length/2)])



    # create Signal object and plot signal
    def create_signal(self):
        # create fft for signal
        self.signal_fft()
        self.original_waveform = self.plot(self.original_data)
        self.modified_waveform = self.plot(self.modified_data)
        self.verticalLayout_6.addWidget(self.original_waveform)
        self.verticalLayout_7.addWidget(self.modified_waveform)
        self.spec_sliders()
        self.open_window()
        self.frame.show()
        # self.play_signal(self.modified_data, self.modified_waveform, 3)  # to be changed to step
        #equalizer
        # self.generate_band()
        self.get_amplitude()
        #self.play_signal(3)  # to be changed to step



    # for plotting after reading signal
    def plot(self, data):
        data_plot = PlotWidget()
        x_range = [0, 2000]
        x = np.arange(0, len(self.original_data), 1)
        data_plot.showGrid(x=True, y=True)
        data_plot.enableAutoRange(x=False, y=True)
        p = data_plot.plot(pen='b', width=0.1)
        p.setData(x, data)
        data_plot.getViewBox().setLimits(xMin=min(self.original_data))
        data_plot.setXRange(x_range[0], x_range[1],padding=0.005)
        return data_plot

    # fft for signal
    def signal_fft(self):
        self.fft = np.fft.rfft(self.original_data)
        self.magnitude_spectrum = np.abs(self.fft)  # for calculating magnitude spectrum
        self.phase_spectrum = np.angle(self.fft)
        self.frequencies = np.fft.rfftfreq(len(self.original_data), d=1 / self.sample_rate)



    # Zoom
    def zoom(self, mode):
        center_x = (self.original_waveform.getAxis("bottom").range[0] +
                    self.original_waveform.getAxis("bottom").range[1]) / 2
        center_y = 0
        # zoom in
        if mode == 1:
            self.original_waveform.getViewBox().scaleBy(y=0.9, x=0.9, center=(center_x, center_y))
            self.modified_waveform.getViewBox().scaleBy(y=0.9, x=0.9, center=(center_x, center_y))
        # zoom out
        else:
            self.original_waveform.getViewBox().scaleBy(y=(1 / 0.9), x=(1 / 0.9), center=(center_x, center_y))
            self.modified_waveform.getViewBox().scaleBy(y=(1 / 0.9), x=(1 / 0.9), center=(center_x, center_y))

    # play function and play as fast as possible
    def play_signal(self, mode):
        self.pause = 0
        self.played = 1
        sig_length = len(self.original_data)
        starting_x = self.original_waveform.getAxis("bottom").range
        x_end = starting_x[1]
        # check if signal reached the end
        if mode ==1:
            self.step =self.step +1
        elif mode == -1 :
            self.step = self.step -1
        print(self.step)
        if starting_x[1] < sig_length:
            i = 1
            # play signal
            print(starting_x[0])
            while x_end < sig_length and starting_x[0] >= min(self.original_data):
                # break if pause is pressed
                if self.pause == 1:
                    break
                self.original_waveform.setXRange(starting_x[0] + self.step * i,
                                                 starting_x[1] + self.step * i,padding=0.005)
                self.modified_waveform.setXRange(starting_x[0] + self.step * i,
                                                 starting_x[1] + self.step * i,padding=0.005)  #
                QtWidgets.QApplication.processEvents()
                # x_end= x_end + step
                x_end = self.original_waveform.getAxis("bottom").range[1]
                i += 1

    def speed_up(self):
        self.pause_signal()
        self.play_signal(1)

    def speed_down(self):
        if self.step >3:
            self.pause_signal()
            self.play_signal(-1)
            

    # pause function
    def pause_signal(self):
        self.pause = 1
        self.played = 0
        winsound.PlaySound(None, winsound.SND_ASYNC)

    # to signal beginning
    def signal_beginning(self, mode):
        self.pause_signal()
        # get original xrange
        x_range = [0, 2000]
        if mode == 1:  # start of the signal
            self.original_waveform.setXRange(x_range[0], x_range[1],padding=0.005)
            self.modified_waveform.setXRange(x_range[0], x_range[1],padding=0.005)  #
        else:
            x_start = self.original_waveform.getAxis("bottom").range[0]
            x_end = self.original_waveform.getAxis("bottom").range[1]
            if (x_start - 10) < 0:
                self.signal_beginning(1)
            else:
                self.original_waveform.setXRange(x_start - 10, x_end - 20,padding=0.005)
                self.modified_waveform.setXRange(x_start - 10, x_end - 20,padding=0.005)  #

    # to signal end
    def signal_end(self, mode):
        self.pause_signal()
        # set xrange to be
        if mode == 1:
            x_end = len(self.original_data)
            self.original_waveform.setXRange(x_end - 2000, x_end,padding=0.005)
            self.modified_waveform.setXRange(x_end - 2000, x_end,padding=0.005)

        else:
            x_start = self.original_waveform.getAxis("bottom").range[0]
            x_end = self.original_waveform.getAxis("bottom").range[1]
            if (x_end + 10) > len(self.original_data):
                self.signal_end(1)
            else:
                self.original_waveform.setXRange(x_start + 20, x_end + 10,padding=0.005)
                self.modified_waveform.setXRange(x_start + 20, x_end + 10,padding=0.005)

    #save plots
    def im_save(self,plot_item,path):
        # signal im save
        plot_data = plot_item
        QtGui.QApplication.processEvents()
        exporter = pg.exporters.ImageExporter(plot_data)
        exporter.parameters()['width'] = 500
        name = path.split("/")[-1]
        exporter.export(name + ".png")


    # save signal plots
    def save(self):
        self.im_save(self.original_waveform.plotItem,self.path)
        self.im_save(self.modified_waveform.plotItem,self.path+'m')
        self.figure.savefig(self.path.split("/")[-1] + "s" + ".png")

    def E_pdf(self):
        self.save()
        self.pins = Pin()
        self.pins.getPins(self.path)
        fileName = 'pdfTable.pdf'
        pdf = SimpleDocTemplate(fileName, pagesize=letter)

        # append table elements
        self.elems = []
        self.pins.genPinTable()  # generate element for each signal
        self.elems.append(self.pins.pinElemTable)
        pdf.build(self.elems)
        print("Report is done")

    def spectro_draw(self,colorcmap):
        self.pallette = colorcmap
        # clearing old figure
        self.figure.clear()
        plt.specgram(self.spec_mag, Fs=self.sample_rate,cmap=colorcmap)
        plt.xlabel('Time(sec)')
        plt.ylabel('Frequency(Hz)')
        self.canvas.draw()

    def color_pallette(self):
        colors = ['plasma','Purples', 'Blues', 'Greens', 'Oranges','cool']        
        if self.radioButton1.isChecked():
            self.spectro_draw(colors[1])
        elif self.radioButton2.isChecked():
            self.spectro_draw(colors[2])
        elif self.radioButton3.isChecked():
            self.spectro_draw(colors[3])
        elif self.radioButton4.isChecked():
            self.spectro_draw(colors[4])
        elif self.radioButton5.isChecked():
            self.spectro_draw(colors[5])
        else:
            self.spectro_draw(colors[0])

    
    def slider_step(self):
        self.current_values=[]
        self.new_amp=[]
        for slider in self.sliders:
            self.current_values.append(slider.value())
            
        for index, current_val in enumerate(self.current_values):
            self.gains[index].setText(str(current_val))

        for index, current_val in enumerate(self.current_values):
            for a in self.As[index]:
                self.new_amp.append(a*current_val)
        
        self.inverse_fft()


    def inverse_fft(self):
        fft = np.multiply(self.new_amp, np.exp(1j * self.phase_spectrum))
        self.modified_data = np.fft.irfft(fft)
        #clear widget
        self.verticalLayout_6.removeWidget(self.original_waveform)
        self.verticalLayout_7.removeWidget(self.modified_waveform)
        #update 
        self.create_signal()
        self.spec_range()
        self.save_sig()

    def save_sig(self):
        write("newData.wav", self.sample_rate, self.modified_data.astype(np.float32))

    def play_sound(self):
        self.save_sig()
        winsound.PlaySound("newData.wav", winsound.SND_ASYNC | winsound.SND_ALIAS )




class OtherWindows(Window):
    def __init__(self):
        super().__init__()
        # # set the title
        # title = "win"
        # self.setWindowTitle(title)

    def config(self, path):
        self.signals_windows[path] = self


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    ui = Window()
    # ui.showMaximized()
    # ui.show()
    sys.exit(app.exec_())
